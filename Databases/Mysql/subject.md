# 基础部分  
**1.drop,truncate,delete区别**
  - delete：删除表的内容，表的结构还存在，不释放空间，可以回滚恢复；  
  - drop：删除表内容和结构，释放空间，没有备份表之前要慎用；  
  - truncate：删除表的内容，表的结构存在，可以释放空间,没有备份表之前要慎用；
    
**2.数据库三范式是什么?**   
  - 1、第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位e5a48de588b6e799bee5baa6e997aee7ad9431333431363034时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。  
  - 2、第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。  
  - 3、第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF。  

**3.union,union all有什么不同？**  
   - union 将两个表连接后删除其重复的项。（交集）  
   - union all 将两个表连接都不删除其重复的项。(并集)  
   
**4.char,varchar2,varchar有什么区别？**   
   - CHAR的长度是固定的，VARCHAR2的长度是可以变化的。 
   - varchar2把所有字符都占两字节处理(一般情况下)，varchar只对汉字和全角等字符占两字节，数字，英文字符等都是一个字节；
   - VARCHAR2把空串等同于null处理，而varchar仍按照空串处理；
   - VARCHAR2字符要用几个字节存储，要看数据库使用的字符集，
   
**5.合并查询有哪些？**
   - union   :合并时去除重复记录
   - union all:  合并时不去除重复记录  
 
**6.SQL语句执行顺序？**
   - 1.FROM
   - 2.ON
   - 3.JOIN
   - 4.WHERE
   - 5.GROUP By
   - 6.CUBE|ROLLUP
   - 7.HAVING
   - 8.SELECT 
   - 9.DISTINCT 
   - 10.ORDER BY
   - 11.LIMIT
       
**7.null的含义**
 - 因为NULL只是一个标识，只要知道此列为NULL即可，NULL值跟任何值比较，返回均为不相同，包括NULL与NULL本身。
   
**8.MySQL,SqlServer,oracle写出字符存储,字符串转时间**  
   - MySQL:SELECT DATE_FORMAT(hiredate,"%Y-%m-%d") FROM users ;
   - Oracle:select to_date("2017-11-2","yyyy-MM-dd HH:mi:ss") from dual;
   - SqlServer: select convert(varchar ,getdate(),120); 
   
**9.update语句可以修改结果集中的数据吗？**
   -  不能直接实现,可以通过INNER JOIN引入内部关联表实现
      
**10.B树和B+树的区别**
   - B树:每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。
   - B+树:只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。  
   
**11.你建过索引吗？建索引的原则**
   - 1.对于查询频率高的字段创建索引
   - 2.对排序,分组,联合查询频率高的字段创建索引 
   - 3.索引数目不宜太对
   - 4.若在实际中,需要将多个列设置索引时,可以采用组合索引
   - 5.选择唯一索引
   - 6.尽量使用数据量少的索引
   - 7.尽量使用前缀来索引 
   - 8.删除不再使用或者很少使用的索引
   
**12.查看SQL执行计划**  
  - explain
  
**13.有十万条数据,写出SQL语句查询其中某字段较大值的几条数据**
  - select * from table order by age desc limit 0,10;
  
**14.子查询与关联查询的区别**
  - 子查询会建立临时表,子查询效率低于关联查询;
  
**15.MySQL InnoDB,MyISAM的特点？**  
   - 1.InnoDB支持事务索引,MyISAM不支持
   - 2.InnoDB提供了行锁,MyISAM写入时锁表,InnoDB行锁也不是绝对的,如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like "%aaa%" 
   - 3.InnoDB不支持FULLTEXT类型索引,MyISAM支持
   - 4.InnoDB不保存表的具体行数,执行count()时会扫描整个表计算多少行
   - 5.DELETE FROM table时,InnoDB会一行一行删除,MyISAM会重建表
   - 6.InnoDB不支持LOAD TABLE FROM MASTER操作（表的拷贝从主服务器转移到从属服务器）；MyISAM表支持。
   - 7.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引；但是在MyISAM表中，可以和其他字段一起建立联合索引。
    
**16.乐观锁和悲观锁的区别？**
   - 乐观锁（ Optimistic Locking）：顾名思义，对加锁持有一种乐观的态度，即先进行业务操作，不到最后一步不进行加锁，"乐观"的认为加锁一定会成功的，在最后一步更新数据的时候再进行加锁。
   - 悲观锁（Pessimistic Lock）：正如其名字一样，悲观锁对数据加锁持有一种悲观的态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
  
**17.行锁和表锁的区别？**
   - 行锁:锁的粒度小，发生锁冲突的概率低、处理并发的能力强；开销大、加锁慢、会出现死锁
   - 表锁:开销小、加锁快、无死锁；锁粒度大，发生锁冲突的概率高，高并发下性能低
     
**18.数据库隔离级别是什么？有什么作用？**
  - 1.Serializable (串行化)：可避免脏读、不可重复读、幻读的发生
  - 2.Repeatable read (可重复读)：可避免脏读、不可重复读的发生
  - 3.Read committed (读已提交)：可避免脏读的发生
  - 4.Read uncommitted (读未提交)：最低级别，任何情况都无法保证
  
**19.MySQL主备同步基本原理**
   - 1.MYSQL主从同步是异步复制的过程，整个同步需要开启3线程，master上开启bin-log日志（记录数据库增、删除、修改、更新操作）；
   - 2.Slave开启I/O线程来请求master服务器，请求指定bin-log中position点之后的内容；
   - 3.Master端收到请求，Master端I/O线程响应请求，bin-log、position之后内容返给salve；
   - 4.Slave将收到的内容存入relay-log中继日志中，生成master.info（记录master ip、bin-log、position、用户名密码）；
   - 5.Slave端SQL实时监测relay-log日志有更新，解析更新的sql内容，解析成sql语句，再salve库中执行；
   - 6.执行完毕之后，Slave端跟master端数据保持一致！

**20.如何优化数据库性能(索引,分库分表,批量操作,分页算法,升级硬盘SSD,业务优化,主从部署)**
  - 1.索引
  - 2.分库分表
  - 3.批量操作
  - 4.分页算法
  - 5.升级硬盘SSD
  - 6.业务优化
  - 7.主从部署
  
**21.SQL什么情况下不会使用索引**
  - 1.不包含
  - 2.不等于
  - 3.函数  
  
**22.一般在什么字段上建立索引**
  - 表的主键,外键必须有索引
  - 经常与其他表进行连接的表,连接字段上应该建立索引
  - 经常出现在where子句中的字段应该建立索引
  - 选择性高的字段上建立索引
  - 索引应该建在小字段上,对于大的文本字段甚至超长字段,不要建立索引
   
**23.MySQL,B+索引实现,行锁实现,SQL优化**
  - 略  
  
24.如何解决高并发减库存问题  
  - 悲观锁
  - 消息队列
  
25.数据库事务的几种粒度  
  - 略
  
#实战部分  
1.数据库三范式,根据秒杀场景设计数据表  
  - 第一范式（1NF）：确定每一列的原子性。每一列都是最小的数据单元，既满足第一范式。
  - 第二范式（2NF）：非键字段必须依赖于键字段。如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。
  - 第三范式（3NF）：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。
  - 数据表:1.秒杀库存表 2.秒杀成功明细表
  
2.数据库的主从复制
   - 1.MYSQL主从同步是异步复制的过程，整个同步需要开启3线程，master上开启bin-log日志（记录数据库增、删除、修改、更新操作）；
   - 2.Slave开启I/O线程来请求master服务器，请求指定bin-log中position点之后的内容；
   - 3.Master端收到请求，Master端I/O线程响应请求，bin-log、position之后内容返给salve；
   - 4.Slave将收到的内容存入relay-log中继日志中，生成master.info（记录master ip、bin-log、position、用户名密码）；
   - 5.Slave端SQL实时监测relay-log日志有更新，解析更新的sql内容，解析成sql语句，再salve库中执行；
   - 6.执行完毕之后，Slave端跟master端数据保持一致！
   
3.死锁怎么解决  
   - 等待，直到超时（innodb_lock_wait_timeout=50s）。
   - 发起死锁检测，主动回滚一条事务，让其他事务继续执行(innodb_deadlock_detect=on)。
   
4.mysql并发情况下怎么解决(通过事务,隔离级别,锁)  
  - 事务
  - 隔离级别
  - 锁
  
5.触发器的作用？  
  - 触发器是一种特殊的存储过程，它在插入，删除或改动特定表中的数据时触发运行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。
  
6.什么是存储过程？用什么来调用？  
  - 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。
  
7.存储过程的优缺点？  
  - 优点
    - 1.提高性能
    - 2.降低网络开销
    - 3.便于进行代码移植
    - 4.更强的安全性
  - 缺点
    - 1.存储过程需要专门的数据库开发人员进行维护,但实际情况是,往往由程序开发人员兼职
    - 2.设计逻辑变更,修改存储过程没有SQL灵活
      
8.存储过程与函数的区别？
  - 1.存储过程用户在数据库中完成特定操作或者任务(如插入,删除等),函数用于返回特定的数据
  - 2.存储过程中声明用procedure,函数用function
  - 3.存储过程不需要返回类型,函数必须返回类型
  - 4.存储过程可作为独立的pl-sql执行,函数不能作为独立的plsql执行,必须作为表达式的一部分
  - 5.存储过程只能通过out和in/out来返回值,函数除了可以使用out,in/out以为,还可以使用return返回值。
  - 6.sql语句(DML或SELECT)中不可调用存储过程,而函数可以。   
  - 总结：如果只有一个返回值,用存储函数,否则,一般用存储过程。
  
9.索引的作用？和它的优点缺点是什么？
  - 优点:
    - 1.通过创建唯一性索引,可以保证数据表中每一行数据的唯一性。
    - 2.可以大大加快数据的检索速度。
    - 3.可以加速表与表之间的连接,特别是在实现数据的参考完整性方面特别有意义。
    - 4.在使用分组和排序子句进行数据检索时,同样可以显著减少查询中分组和排序的时间。
    - 5.通过使用索引,可以在查询的过程中,使用优化隐藏器,提高系统的性能。
  - 缺点:
    - 1.创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加。
    - 2.索引需要占用物理空间,除了数据表占数据空间之外,每一个索引还要占用一定的物理空间,如果要建立聚簇索引,那么需要的空间会更大。  
    - 3.当对表中的数据进行增加,删除和修改的时候,索引也要动态维护,这样就降低了数据的维护速度。
     
10.什么样的字段适合建立索引？
   - 表的主键,外键必须有索引
   - 经常与其他表进行连接的表,连接字段上应该建立索引
   - 经常出现在where子句中的字段应该建立索引
   - 选择性高的字段上建立索引
   - 索引应该建在小字段上,对于大的文本字段甚至超长字段,不要建立索引
   
11.索引类型有哪些？  
  - FULLTEXT(全文索引),只有MyISAM引擎支持
  - HASH索引
  - BTREE
  - RTREE
  
12.什么是事务？什么是锁？ 
  - 事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，由 一个有限的数据库操作序列构成；
  - 锁机制用于管理对共享资源的并发访问(包括但不限于行记录)。
  
13.什么叫视图？游标是什么？
  - 视图:一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。  
  - 游标:是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
  
14.视图的优缺点？
  - 优点:
    - 简单化,数据所见即所得
    - 安全性,用户只能查询或修改他们所能见到得到的数据
    - 逻辑独立性,可以屏蔽真实表结构变化带来的影响
  - 缺点:
    - 性能相对较差,简单的查询也会变的稍显复杂
    - 修改不方便,特别是复杂的聚合视图基本无法修改
        
15.列举几种表连接方法,有什么区别？
  - 笛卡尔积:两表关联，把左表的列和右表的列通过笛卡尔积的形式表达出来。(select * from t1 join t2;)
  - 左连接:两表关联，左表全部保留，右表关联不上用null表示。(select * from t1 left join t2 on t1.id = t2.id;)  
  - 右连接:右表全部保留，左表关联不上的用null表示。(select * from t1 right join t2 on t1.id =t2.id;)
  - 内连接:两表关联,保留两表中交集的记录。（select * from t1 inner join t2 on t1.id = t2.id;）
  - 左表独有:两表关联，查询左表独有的数据。（select * from t1 left join t2 on t1.id = t2.id where t2.id is null;）
  - 右表独有:两表关联，查询右表独有的数据。（select * from t1 right join t2 on t1.id = t2.id where t1.id is  null;）
  - 全连接:两表关联，查询它们的所有记录。(select * from t1 left join t2 on t1.id = t2.id  union  select * from t1 right join t2 on t1.id = t2.id;)
  - 并集去交集:两表关联，取并集然后去交集。(select * from t1 left join t2 on t1.id = t2.id where t2.id is null union  select * from t1 right join t2 on t1.id = t2.id where t1.id is null;)
        
16.主键和外键的区别？  
  - 主键是唯一标识一条记录，不能有重复，不允许为空；而外键可以重复，可以是空值
  - 主键是用来保持数据完整性，外键是用来建立与其他表联系用的
  - 主键只有一个，外键可以有多个
  
17.在数据库中查询语句速度很慢,如何优化？
  - 建立索引
  - 减少表之间的关联
  - 优化sql,尽量让sql很快定位数据,不用让sql做全表查询
  - 简化查询字段,没用的字段不要
  
18.数据库三范式式是什么？  
   - 第一范式（1NF）：确定每一列的原子性。每一列都是最小的数据单元，既满足第一范式。
   - 第二范式（2NF）：非键字段必须依赖于键字段。如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。
   - 第三范式（3NF）：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。

19.varchar2与varchar有什么区别？
   - 1.varchar2把所有字符都占两字节处理(一般情况下)，varchar只对汉字和全角等字符占两字节，数字，英文字符等都是一个字节；
   - 2.VARCHAR2把空串等同于null处理，而varchar仍按照空串处理；
   - 3.VARCHAR2字符要用几个字节存储，要看数据库使用的字符集，
  
20.Oracle与Mysql的区别？  
  - 1.对事务的提交:MySQL默认自动提交,而Oracle不自动提交,需要用户手动提交,需要在写commit指令或者点击commit按钮.
  - 2.分页查询:MySQL直接在SQL语句中写"select...from...where...limit x,y",有limit可以实现分页;而Oracle则需要用到伪列ROWNUM嵌套查询
  - 3.事务隔离级别:MySQL是read commited的隔离级别,而Oracle是repeatable read的隔离级别,同时二者都支持serializable串行化事务隔离级别,可以实现最高级别的读一致性.每个session提交后其他session才能看到提交的更改.Oracle通过undo表空间中构造多版本数据来实现读写一致性,每个session查询时,如果对应的数据库发生变化,Oracle会在undo表空间中为这个session构造它查询时的旧数据块。MySQL没有类似Oracle的构造多版本数据块的机制,只支持read commited的隔离级别。一个session读取数据时,其他session不能更改数据,但可以在表最后插入数据。session更新数据时,要加上排它锁,其他session无法访问数据
  - 4.对事物的支持:MySQL只有innodb存储引擎行级锁的情况下才可支持事务,而Oracle则完全支持事务
  - 5.保持数据持久性:MySQL是在数据库更新或者重启,则会丢失数据,Oracle把提交的sql操作写入了在线联机日志文件中,保持到了磁盘,可以随时恢复
  - 6.并发性:MySQL以表级锁为主,对资源锁定的粒度很大,如果一个session对一个表加锁时间过长,会让其他session无法更新此表中的数据。虽然InnoDb引擎的表可以用行级锁,但这个行级锁的机制依赖于表的索引,如果表没有索引,或者sql语句中没有使用索引,那么仍然使用表级锁。Oracle使用行级锁,对资源锁定的粒度要小很多,只需要锁定sql需要的资源,并且加锁是在数据库中的数据行上,不依赖于索引。所以Oracle对并发性的支持要很很多。
  - 7.逻辑备份:MySQL逻辑备份时要锁定数据,才能保证备份的数据是一致的,影响业务正常的dml使用,而Oracle逻辑备份时不锁定数据,而备份数据是一致的
  - 8.复制
     - MySQL:复制服务器配置简单,但主库出问题时,从库有可能丢失一定的数据。且需要手工切换从库到主库
     - Oracle:既有推送或拉式的传统数据复制,也有dataguard的双机或多机容灾机制,主库出现问题时,可以自动切换备库到主库,但配置管理比较复杂。
  - 9.性能诊断
     - MySQLd的诊断调优方法较少,主要有慢查询日志
     - Oracle有各种成熟的性能诊断调优工具,能实现很多自动分析,诊断功能。比如awr,addm,sqltrace,tkproof等
  - 10.权限与安全
     - Mysql的用户与主机相关,感觉没有什么意义,另外更容易被仿冒主机及ip有可乘之机。
     - Oracle的权限与安全概念比较传统,中规中矩。
  - 11.分表与分区索引
     - MySQL的分区表还不太成熟稳定。
     - Oracle的分区表和分区索引功能比较成熟,可以提高用户访问db的体验。
  - 12.管理工具
     - MySQL管理工具比较少,在linux下的管理工具的安装有时要安装额外的包(phpmyadmin,etc),有一定复杂性。
     - Oracle有很多成熟的命令行,图形界面,wen管理工具,还有很多第三方的管理工具,管理方便高效。
  - 13.最重要的区别
     - MySQL是轻量型数据库,并且免费,没有服务恢复数据。
     - Oracle是重量型数据库,收费,Oracle公司对Oracle数据库有很多服务。
                 
21.order by与group by的区别
  - order by:用来排序
  - group by:用来分组  

#高级进阶部分  
1.请解释关系型数据库概念及其特点？  
  - 概念:关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组
  - 特点：
    - 1.数据集中控制
    - 2.数据独立
    - 3.数据共享
    - 4.减少数据冗余
    - 5.数据结构化
    - 6.同意的数据保护功能
    
2.请说出关系型数据库的典型产品,特点及应用场景？
  - SQLServer
    - 特点:真正的客户机/服务器体验结构。图形化用户界面。丰富的编程接口工具。与Windows NT完全集成。具有很好的伸缩性。
    - 应用场景:主机为Windows系统,主要应用于web网站的建设,承载中小型web后台数据。
  - MySQL
    - 特点:体积小,总拥有成本低,开放源代码,可运行在多数系统平台上,轻量级易扩展。
    - 应用场景:广泛的应用在Internet上的中小型网站中。
  - Oracle
    - 特点:跨平台运行,安全性方面,性能最高。对硬件要求高,价格昂贵。
    - 应用场景:大部分国企事业单位都用Oracle,在电信行业占用最大的份额。      

3.请解释非关系型数据库概念及主要特点？
  - 非关系型数据库也被称为NoSQL数据库，数据存储不需有特有固定的表结构
  - 特点：高性能、高并发、简单易安装
     
4.请说出非关系型数据库的典型产品,特点及应用场景？ 
  - 1、memcaced 纯内存
  - 2、redis 持久化缓存
  - 3、mongodb 面向文档
  - 如果需要短时间响应的查询操作，没有良好模式定义的数据存储，或者模式更改频繁的数据存储还是用NoSQL
          
5.请详细描述SQL语句分类及对应代表性关键字？ 
   - DDL 数据定义语言，用来定义数据库对象：库、表、列
     - 代表性关键字：create alter drop
   - DML 数据操作语言，用来定义数据库记录
     - 代表性关键字:insert delete update
   - DCL 数据控制语言，用来定义访问权限和安全级别
     - 代表性关键字:grant deny revoke
   - DQL 数据查询语言，用来查询记录数据
     - 代表性关键字:select
     
6.请详细描述char(4)和varchar(4)的差别？  
  - char长度是固定不可变的，varchar长度是可变的（在设定内）比如同样写入cn字符，char类型对应的长度是4(cn+两个空格),但varchar类型对应长度是2
  
7.如何授权oldboy用户从172.16.1.0/24访问数据库？ 
  - grant all on *.* to oldboy@'172.16.1.0/24' identified by '123456';
   
8.什么是MySQL多实例,如何配置MySQL多实例？ 
  - mysql多实例就是在同一台服务器上启用多个mysql服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展
  - 多实例的配置方法有两种：
    - 1、一个实例一个配置文件，不同端口
    - 2、同一配置文件(my.cnf)下配置不同实例，基于mysqld_multi工具 
    
9.如何加强MySQL安全,请给出可行的具体措施？
  - 1、删除数据库不使用的默认用户
  - 2、配置相应的权限（包括远程连接）
  - 3、不可在命令行界面下输入数据库的密码
  - 4、定期修改密码与加强密码的复杂度  
  
10.delete和truncate删除数据的区别？
  - 前者删除数据可以恢复，它是逐条删除速度慢
  - 后者是物理删除，不可恢复，它是整体删除速度快  
  
11.MySQL Sleep线程过多如何解决？ 
  - 1、可以杀掉sleep进程，kill PID
  - 2、修改配置，重启服务 
    - [mysqld]  
      wait_timeout = 600    
      interactive_timeout=30
    - 如果生产服务器不可随便重启可以使用下面的方法解决  
      set global wait_timeout=600  
      set global interactive_timeout=30;
    
12.sort_buffer_size参数作用?如何在线修改生效？ 
  - 在每个connection(session)第一次连接时需要使用到，来提访问性能   
     set global sort_buffer_size = 2M  
     
13.如何在线正确清理MySQL binlog？  
  - 手工删除：
    - 首先查看主从库正在使用的binlog文件名称 
    - show master(slave) status\G
    - 删除之前一定要备份
    - purge master logs before'2017-09-01 00:00:00'; 
    - 删除指定时间前的日志
    - purge master logs to'mysql-bin.000001';
    - 删除指定的日志文件
  - 自动删除：
    - 通过设置binlog的过期时间让系统自动删除日志
    - show variables like 'expire_logs_days'; 
    - set global expire_logs_days = 30;
  
14.Binlog工作模式有哪些？各什么特点,企业如何选择？ 
   - 1.Row(行模式)；
      - 日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改
   - 2.Statement(语句模式)
      - 每一条修改的数据都会完整的记录到主库master的binlog里面，在slave上完整执行在master执行的sql语句
   - 3.mixed(混合模式)
      - 结合前面的两种模式，如果在工作中有使用函数 或者触发器等特殊功能需求的时候，使用混合模式，数据量达到比较高时候，它就会选择 statement模式，而不会选择Row Level行模式 

15.误操作执行了一个drop库的SQL语句,如何完整恢复？  
  - 1、停止主从复制，在主库上执行锁表并刷新binlog操作，接着恢复之前的全备文件（比如0点的全备）
  - 2、将0点时的binlog文件与全备到故障期间的binlog文件合并导出成sql语句
    - mysqlbinlog --no-defaults mysql-bin.000011 mysql-bin.000012 >bin.sql
  - 3、将导出的sql语句中drop语句删除，恢复到数据库中 
    - mysql -uroot -pmysql123 < bin.sql
    
16.mysqldump备份使用了-A-B参数,如何实现恢复单表？  
  - -A 此参数作用是备份所有数据库（相当于--all-databases）
  - -B databasename 备份指定数据（单库备份使用）
  
17.详述了MySQL主从复制原理及配置主从的完整步骤。
  - 主从复制的原理如下：
    - 主库开启binlog功能并授权从库连接主库，从库通过change master得到主库的相关同步信息,然后连接主库进行验证，主库IO线程根据从库slave线程的请求，从master.info开始记录的位置点向下开始取信息，同时把取到的位置点和最新的位置与binlog信息一同发给从库IO线程，从库将相关的sql语句存放在relay-log里面，最终从库的sql线程将relay-log里的sql语句应用到从库上，至此整个同步过程完成，之后将是无限重复上述过程
  - 完整步骤如下：
    - 1、主库开启binlog功能，并进行全备，将全备文件推送到从库服务器上
    - 2、show master status\G 记录下当前的位置信息及二进制文件名
    - 3、登陆从库恢复全备文件
    - 4、执行change master to 语句
    - 5、执行start slave and show slave status\G  
    
18.如何开启从库的binlog功能？  
  - 修改配置文件加上下面的配置
    - log_bin=slave-bin
    - log_bin_index=slave-bin.index
  - 需要重启服务生效
  
19.MySQL如何实现双向互为主从复制,并说明应用场景？  
  - 双向同步主要应用于解决单一主库写的压力，具体配置如下
  - 主库配置
    - [mysqld]
    - auto_increment_increment  = 2  #起始ID
    - auto_increment_offset     = 1  #ID自增间隔
    - log-slave-updates   
  - 从库配置
    - [mysqld]
    - auto_increment_increment  = 2  #起始ID
    - auto_increment_offset     = 2  #ID自增间隔
    - log-slave-updates 
  - 主从库服务器都需要重启mysql服务
  
20.MySQL如何实现级联同步,并说明应用场景？  
  - 级联同步主要应用在从库需要做为其它数据库的主库
  - 在需要做级联同步的数据库配置文件增加下面的配置即可
    - log_bin=slave-bin
    - log_bin_index=slave-bin.index
   
21.MySQL主从复制故障如何解决？ 
  - 登陆从库
    - 1、执行stop slave;停止主从同步
    - 2、然后set global sql_slave_skip_counter = 1;跳过一步错误
    - 3、最后执行 start slave;并查看主从同步状态
  - 需要重新进行主从同步操作步骤如下
  - 进入主库
    - 1、进行全备数据库并刷新binlog,查看主库此的状态
    - 2、恢复全备文件到从库，然后执行change master 
    - 3、开启主从同步start slave;并查看主从同步状态
  
22.如何监控主从复制是否故障？  
  - mysql -uroot -ppassowrd -e "show slave status\G" |grep -E "Slave_IO_Running|Slave_SQL_Running"|awk '{print $2}'|grep -c Yes
  - 通过判断Yes的个数来监控主从复制状态，正常情况等于2
   
23.MySQL数据库如何实现读写分离？  
  - 1、通过开发程序实现
  - 2、通过其它工具实现（如mysql-mmm）
  
24.生产一主多从从库宕机,如何手工恢复？ 
  - 1、登陆各个从库停止同步，并查看谁的数据最新，将它设置为新主库让其它从库同步其数据
  - 2、修复好主库之后，重新操作主从同步的步骤就可以了